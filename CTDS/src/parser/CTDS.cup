/*
 * Autores: Jaimez Jacinto, Pereyra Orcasitas Nicolas
 * Proyecto: CompiladorCTDS
 * definicion de la gramatica
 */


import java_cup.runtime.*;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};


//code

parser code {:
     public void syntax_error(Symbol s){
        System.out.println("Sintax error in line: " + s.left +" column: "+ s.right +" symbol:"+s.value);
     }

     public void unrecovered_syntax_error(Symbol s){
        System.out.println("Unrecovered sintax error in line: " + s.left +" column: "+ s.right +" symbol:"+s.value);
     }


:}

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals (tokens returned by the scanner).*/

/*LITERALES*/
terminal    INT_LITERAL; 
terminal    FLOAT_LITERAL;
/*OPERADORES*/
terminal    PLUS, MINUS, TIMES, DIVIDE, MOD, OR, AND, NOT, EQ, NOTEQ, EQEQ, LT, GT, LTEQ, GTEQ, PLUSEQ, MINUSEQ;
terminal UMINUS;
/*SEPARADORES*/
terminal    SEMI, COMMA, LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, DOT;    
/*PALABRAS RESERVADAS*/
terminal    TYPE_BOOLEAN, BREAK, CLASS, CONTINUE, ELSE, IF, FOR, WHILE, TYPE_FLOAT, TYPE_INT, RETURN, VOID, EXTERN;
terminal    TRUE;
terminal    FALSE;
/*IDENTIFICADORES*/
terminal    IDENTIFIER;


/*operadores*/
non terminal    assign_op;
/*literales*/
non terminal    literal;
non terminal    int_literal;
non terminal    bool_literal;
non terminal    float_literal;


non terminal program, decl, field_decl,  method_decl, id_def, id, class_decl;
non terminal expr_sequence;
non terminal parameters ;
non terminal statement_decl;
non terminal type;
non terminal method_call;
non terminal location; 
non terminal location_decl, method;
non terminal expr;
non terminal statement;
non terminal body, block ;
non terminal operations;

/* Precedences */
precedence left OR;
precedence left AND;
precedence nonassoc LT, GT, LTEQ, GTEQ, NOTEQ, EQEQ;
precedence left PLUS, MINUS;   
precedence left TIMES, DIVIDE, MOD;
precedence right UMINUS;
precedence right IF, ELSE;

start with program;

program ::= class_decl;

class_decl ::= CLASS id LKEY decl RKEY class_decl
            |CLASS id LKEY RKEY class_decl
						| ;
             
decl ::= field_decl
            | method_decl
            | field_decl method_decl;

field_decl ::= type id_def SEMI
            | field_decl type id_def SEMI;

id_def ::= location_decl
            | id_def COMMA location_decl;


location_decl ::= id
            | id LBRACKET int_literal RBRACKET;
    

method_decl ::= method
            | method_decl method;

method ::= type id LPAREN RPAREN body                      
            |VOID id LPAREN RPAREN body
            |VOID id LPAREN parameters RPAREN body  
            |type id LPAREN parameters RPAREN body;

parameters ::= type id 
            | parameters COMMA type id;


body ::=  LKEY block:b RKEY{:RESULT= new Body(b);:}
            |EXTERN SEMI{:RESULT= new ExternStmt();:};
                                                                         
block ::= statement_decl:sd {: RESULT = new Block(sd);:}
            | field_decl {: RESULT = new Block(null);:}
            | field_decl statement_decl:sd  {: RESULT = new Block(sd);:}
            | {: RESULT = new Block(null);:};

type ::= TYPE_INT {:tipoVar = Type.INT;  RESULT = Type.INT ; :}
       | TYPE_FLOAT {:tipoVar = Type.FLOAT; RESULT = Type.FLOAT ; :}
       | TYPE_BOOLEAN {:tipoVar = Type.BOOL; RESULT = Type.BOOL ; :};

statement_decl ::= statement:s {: LinkedList<Statement> l = new LinkedList<Statement>() ;
                                l.add(s);
				RESULT = l; :} 
		| statement_decl:sd statement:s {: sd.add(s);
						RESULT = sd ; :};

statement ::= location:loc assign_op:op expr:e SEMI  {:RESULT =  new AssignStmt(loc,op,e):}
            | method_call:m SEMI {:RESULT = m;:} // ESTA BIEN ESTE?
            | IF LPAREN expr:cond RPAREN statement:ifBl ELSE statement:elseBl {:RESULT = new ifStmt(cond,ifBl,elseBl);:}
            | IF LPAREN expr:cond RPAREN statement:ifBl {:RESULT = new ifStmt(cond,ifBl);:}
            | FOR id EQ expr COMMA expr statement // ESTO PARECE QUE ESTA MAL EL STATEMENT
            | WHILE expr statement // LO MISMO DE ARRIBA
            | RETURN expr:exp SEMI {:RESULT= new ReturnStmt(exp);:}
            | RETURN SEMI {:RESULT= new ReturnStmt();:}
            | BREAK SEMI  {:RESULT= new BreakStmt();:}
            | CONTINUE SEMI {:RESULT= new ContinueStmt();:}
            | SEMI  //COMO SE HACE ACA?
            | body:b {:RESULT = b;:};


assign_op ::= EQ {: RESULT = AssignOpType.ASSIGN;:}
            | PLUSEQ  {: RESULT = AssignOpType.INCREMENT;:}
            | MINUSEQ  {: RESULT = AssignOpType.DECREMENT;:};

method_call ::= id:i LPAREN RPAREN  {:RESULT = new MethodCall(i);:}                                      
            | id:i LPAREN expr_sequence:exp RPAREN  {:RESULT = new MethodCall(i,exp);:}  
            | id:i DOT method_call;// ANALZAR CUANTAS VECES PUEDO HACERLO AL IGUAL QUE LOCATION

location ::= id:i {:RESULT = new VarLocation(i);:}
            |id DOT location //cuantas veces puede tener location?
            |id:i LBRACKET expr:exp RBRACKET;{:RESULT = new VarLocation(i,exp);:}

expr_sequence ::= expr expr //REEEEEEEEEEEVISAR !!!!! 
            | expr_sequence COMMA expr ; 
 
expr ::= location:loc {: RESULT =loc ; :}
            | method_call:mc {: RESULT = mc ; :}
            | literal:l {: RESULT =l ; :} 
            | expr:e operations:op expr:e2 {: RESULT = new BinOpExpr(e,op,e2) ; :} 
            | MINUS expr:e {: RESULT = new UnaryOpExpr(UnaryOpType.MINUS,e) ; :}  %prec UMINUS 
            | NOT expr:e {: RESULT = new UnaryOpExpr(UnaryOpType.NOT,e) ; :}  %prec UMINUS
            | LPAREN expr RPAREN {: RESULT = e; :};

operations ::= PLUS {: RESULT BinOpType.PLUS; :}
            | MINUS {: RESULT BinOpType.MINUS; :}
            | TIMES {: RESULT BinOpType.TIMES; :}
            | MOD {: RESULT BinOpType.MOD; :}
            | DIVIDE {: RESULT BinOpType.DIVIDE; :}
            | LT {: RESULT BinOpType.LT; :}
            | GT {: RESULT BinOpType.GT; :}
            | LTEQ {: RESULT BinOpType.LTEQ; :}
            | GTEQ {: RESULT BinOpType.GTEQ; :}
            | EQEQ {: RESULT BinOpType.EQEQ; :}
            | NOTEQ {: RESULT BinOpType.NOTEQ; :}
            | AND {: RESULT BinOpType.AND; :}
            | OR {: RESULT BinOpType.OR; :}; 
    
literal ::= int_literal:il {: RESULT = il ; :}
            | float_literal:fl {: RESULT = fl ; :}
            | bool_literal:bl {: RESULT = bl ; :};
    
id ::= IDENTIFIER:i {: RESULT = i ;:};

int_literal ::= INT_LITERAL:n {: RESULT = new IntLiteral(n) ;:};

bool_literal ::= TRUE:t {: RESULT = new BoolLiteral(t) ;:} 
            | FALSE:f {: RESULT = new BoolLiteral(f) ;:} ;

float_literal ::= FLOAT_LITERAL:f {: RESULT = new FloatLiteral(f);:} ;
