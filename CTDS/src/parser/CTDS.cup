/*
 * Autores: Jaimez Jacinto, Pereyra Orcasitas Nicolas
 * Proyecto: CompiladorCTDS
 * definicion de la gramatica
 */


import java_cup.runtime.*;

/* Preliminaries to set up and use the scanner.  */
//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};


//code

parser code {:
     public void syntax_error(Symbol s){
        System.out.println("Sintax error in line: " + s.left +" column: "+ s.right +" symbol:"+s.value);
     }

     public void unrecovered_syntax_error(Symbol s){
        System.out.println("Unrecovered sintax error in line: " + s.left +" column: "+ s.right +" symbol:"+s.value);
     }


:}

/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals (tokens returned by the scanner).*/

/*LITERALES*/
terminal    INT_LITERAL; 
terminal    FLOAT_LITERAL;
/*OPERADORES*/
terminal    PLUS, MINUS, TIMES, DIVIDE, MOD, OR, AND, NOT, EQ, NOTEQ, EQEQ, LT, GT, LTEQ, GTEQ, PLUSEQ, MINUSEQ;
terminal UMINUS;
/*SEPARADORES*/
terminal    SEMI, COMMA, LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, DOT;    
/*PALABRAS RESERVADAS*/
terminal    TYPE_BOOLEAN, BREAK, CLASS, CONTINUE, ELSE, IF, FOR, WHILE, TYPE_FLOAT, TYPE_INT, RETURN, VOID, EXTERN;
terminal    TRUE;
terminal    FALSE;
/*IDENTIFICADORES*/
terminal    IDENTIFIER;


/*operadores*/
non terminal    assign_op;
/*literales*/
non terminal    literal;
non terminal    int_literal;
non terminal    bool_literal;
non terminal    float_literal;


non terminal program, decl, field_decl,  method_decl, id_def, id, class_decl;
non terminal expr_sequence;
non terminal parameters ;
non terminal statement_decl;
non terminal type;
non terminal method_call;
non terminal location; 
non terminal location_decl, method;
non terminal expr;
non terminal statement;
non terminal body, block ;
non terminal operations;

/* Precedences */
precedence left OR;
precedence left AND;
precedence nonassoc LT, GT, LTEQ, GTEQ, NOTEQ, EQEQ;
precedence left PLUS, MINUS;   
precedence left TIMES, DIVIDE, MOD;
precedence right UMINUS;
precedence right IF, ELSE;

start with program;

program ::= class_decl:cd {:RESULT = new Program(cd); :};

class_decl ::= CLASS id:i LKEY decl:d RKEY class_decl:l {: l.add(new ClassDeclaration(i,d)) ;
            RESULT = l; :}
            |CLASS id:i LKEY RKEY class_decl:l {: l.add(new ClassDeclaration(i)) ;
            RESULT = l; :}
            | {: LinkedList<ClassDeclaration> l = new LinkedList<ClassDeclaration>() ;
            RESULT = l; :};
             
decl ::= field_decl:fd {:RESULT = new Declaration(fd,null):;}
            | method_decl:md {:RESULT = new Declaration(null,md):;}
            | field_decl:fd method_decl:md {:RESULT = new Declaration(fd,md):;};

field_decl ::= type:t id_def:id SEMI {: LinkedList<FieldDeclaration> l = new LinkedList<FieldDeclaration>() ;
                                l.add(new FieldDeclaration(t,id) );
				RESULT = l; :}
            | field_decl:fd type:t id_def:id SEMI  {: fd.add(new FieldDeclaration(t,id) );
				RESULT = fd; :};

id_def ::= location_decl:ld {: LinkedList<LocationDeclaration> l = new LinkedList<LocationDeclaration>() ;
                                l.add(ld);
				RESULT = l; :};
            | id_def:l COMMA location_decl:ld {: l.add(ld);
				RESULT = l; :};;


location_decl ::= id:i {:RESULT = new LocationDeclaration(i); :}
            | id:i LBRACKET int_literal:il RBRACKET {:RESULT = new LocationDeclaration(i,il); :};
    

method_decl ::= method:m {: LinkedList<Method> l = new LinkedList<Method>() ;
                                l.add(m);
				RESULT = l; :} 
            | method_decl:l method:m {: l.add(m);
						RESULT = l ; :};

method ::= type:t id:i LPAREN RPAREN body:b      {:RESULT = new Method(t,i,b);:}               
            |VOID:t id:i LPAREN RPAREN body {:RESULT = new Method(t,i,b);:}
            |VOID:t id:i LPAREN parameters:p RPAREN body:b  {:RESULT = new Method(t,i,p,b);:}
            |type:t id:i LPAREN parameters:p RPAREN body:b {:RESULT = new Method(t,i,p,b);:};

parameters ::= type:t id:i {: LinkedList<Parameter> l = new LinkedList<Parameter>() ; l.add(new Parameter(t,i)); RESULT= l;:}
             | parameters:l COMMA type:t id:i {:  l.add(new Parameter(t,i)); RESULT= l;:};


body ::=  LKEY block:b RKEY{:RESULT= new Body(b);:}
            |EXTERN SEMI{:RESULT= new ExternStmt();:};
                                                                         
block ::= statement_decl:sd {: RESULT = new Block(sd);:}
            | field_decl {: RESULT = new Block(null);:}
            | field_decl statement_decl:sd  {: RESULT = new Block(sd);:}
            | {: RESULT = new Block(null);:};

type ::= TYPE_INT {:tipoVar = Type.INT;  RESULT = Type.INT ; :}
       | TYPE_FLOAT {:tipoVar = Type.FLOAT; RESULT = Type.FLOAT ; :}
       | TYPE_BOOLEAN {:tipoVar = Type.BOOL; RESULT = Type.BOOL ; :};

statement_decl ::= statement:s {: LinkedList<Statement> l = new LinkedList<Statement>() ;
                                l.add(s);
				RESULT = l; :} 
		| statement_decl:sd statement:s {: sd.add(s);
						RESULT = sd ; :};

statement ::= location:loc assign_op:op expr:e SEMI  {:RESULT =  new AssignStmt(loc,op,e):}
            | method_call:m SEMI {:RESULT = m;:}
            | IF LPAREN expr:cond RPAREN statement:ifBl ELSE statement:elseBl {:RESULT = new IfStmt(cond,ifBl,elseBl);:}
            | IF LPAREN expr:cond RPAREN statement:ifBl {:RESULT = new IfStmt(cond,ifBl);:}
            | FOR id:i EQ expr:e COMMA expr:e2 statement:s {:RESULT = new ForStmt(id,e,e2,s);:}
            | WHILE expr statement // LO MISMO DE ARRIBA
            | RETURN expr:exp SEMI {:RESULT= new ReturnStmt(exp);:}
            | RETURN SEMI {:RESULT= new ReturnStmt();:}
            | BREAK SEMI  {:RESULT= new BreakStmt();:}
            | CONTINUE SEMI {:RESULT= new ContinueStmt();:}
            | SEMI 
            | body:b {:RESULT = b;:};


assign_op ::= EQ {: RESULT = AssignOpType.ASSIGN;:}
            | PLUSEQ  {: RESULT = AssignOpType.INCREMENT;:}
            | MINUSEQ  {: RESULT = AssignOpType.DECREMENT;:};

method_call ::= id:i LPAREN RPAREN  {:RESULT = new MethodCall(i);:}                                      
            | id:i LPAREN expr_sequence:exp RPAREN  {:RESULT = new MethodCall(i,exp);:}  
            | id:i DOT method_call:mc  {:RESULT = new MethodCall(i,mc);:} ; {  

location ::= id:i {:RESULT = new VarLocation(i);:}
            |id:i DOT location:l {:RESULT = new VarLocation(i,l);:}
            |id:i LBRACKET expr:exp RBRACKET;{:RESULT = new VarLocation(i,exp);:}

expr_sequence ::= expr:e {: LinkedList<Expression> l = new LinkedList<Expression>() ;
			l.add(e);
			RESULT = l; :}   
            | expr_sequence:exps COMMA expr:exp {: exps.add(exp); 
                                                RESULT = exps;:};
 
expr ::= location:loc {: RESULT =loc ; :}
            | method_call:mc {: RESULT = mc ; :}
            | literal:l {: RESULT =l ; :} 
            | expr:e operations:op expr:e2 {: RESULT = new BinOpExpr(e,op,e2) ; :} 
            | MINUS expr:e {: RESULT = new UnaryOpExpr(UnaryOpType.MINUS,e) ; :}  %prec UMINUS 
            | NOT expr:e {: RESULT = new UnaryOpExpr(UnaryOpType.NOT,e) ; :}  %prec UMINUS
            | LPAREN expr RPAREN {: RESULT = e; :};

operations ::= PLUS {: RESULT BinOpType.PLUS; :}
            | MINUS {: RESULT BinOpType.MINUS; :}
            | TIMES {: RESULT BinOpType.TIMES; :}
            | MOD {: RESULT BinOpType.MOD; :}
            | DIVIDE {: RESULT BinOpType.DIVIDE; :}
            | LT {: RESULT BinOpType.LT; :}
            | GT {: RESULT BinOpType.GT; :}
            | LTEQ {: RESULT BinOpType.LTEQ; :}
            | GTEQ {: RESULT BinOpType.GTEQ; :}
            | EQEQ {: RESULT BinOpType.EQEQ; :}
            | NOTEQ {: RESULT BinOpType.NOTEQ; :}
            | AND {: RESULT BinOpType.AND; :}
            | OR {: RESULT BinOpType.OR; :}; 
    
literal ::= int_literal:il {: RESULT = il ; :}
            | float_literal:fl {: RESULT = fl ; :}
            | bool_literal:bl {: RESULT = bl ; :};
    
id ::= IDENTIFIER:i {: RESULT = i ;:};

int_literal ::= INT_LITERAL:n {: RESULT = new IntLiteral(n) ;:};

bool_literal ::= TRUE:t {: RESULT = new BoolLiteral(t) ;:} 
            | FALSE:f {: RESULT = new BoolLiteral(f) ;:} ;

float_literal ::= FLOAT_LITERAL:f {: RESULT = new FloatLiteral(f);:} ;
